/*
 * angular-ui-bootstrap
 * http://angular-ui.github.io/bootstrap/

 * Version: 2.5.0 - 2017-01-28
 * License: MIT
 */angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.datepicker", "ui.bootstrap.dateparser", "ui.bootstrap.isClass", "ui.bootstrap.datepickerPopup", "ui.bootstrap.position", "ui.bootstrap.dropdown", "ui.bootstrap.multiMap", "ui.bootstrap.modal", "ui.bootstrap.stackedMap", "ui.bootstrap.typeahead", "ui.bootstrap.debounce", "ui.bootstrap.tabs"]), angular.module("ui.bootstrap.tpls", ["uib/template/datepicker/datepicker.html", "uib/template/datepicker/day.html", "uib/template/datepicker/month.html", "uib/template/datepicker/year.html", "uib/template/datepickerPopup/popup.html", "uib/template/modal/window.html", "uib/template/typeahead/typeahead-match.html", "uib/template/typeahead/typeahead-popup.html", "uib/template/tabs/tab.html", "uib/template/tabs/tabset.html"]), angular.module("ui.bootstrap.datepicker", ["ui.bootstrap.dateparser", "ui.bootstrap.isClass"]).value("$datepickerSuppressError", !1).value("$datepickerLiteralWarning", !0).constant("uibDatepickerConfig", { datepickerMode: "day", formatDay: "dd", formatMonth: "MMMM", formatYear: "yyyy", formatDayHeader: "EEE", formatDayTitle: "MMMM yyyy", formatMonthTitle: "yyyy", maxDate: null, maxMode: "year", minDate: null, minMode: "day", monthColumns: 3, ngModelOptions: {}, shortcutPropagation: !1, showWeeks: !0, yearColumns: 5, yearRows: 4 }).controller("UibDatepickerController", ["$scope", "$element", "$attrs", "$parse", "$interpolate", "$locale", "$log", "dateFilter", "uibDatepickerConfig", "$datepickerLiteralWarning", "$datepickerSuppressError", "uibDateParser", function (e, t, n, a, i, o, r, s, l, u, c, d) { function p(t) { e.datepickerMode = t, e.datepickerOptions.datepickerMode = t } function f(t) { var n; if (angular.version.minor < 6) n = t.$options || e.datepickerOptions.ngModelOptions || l.ngModelOptions || {}, n.getOption = function (e) { return n[e] }; else { var a = t.$options.getOption("timezone") || (e.datepickerOptions.ngModelOptions ? e.datepickerOptions.ngModelOptions.timezone : null) || (l.ngModelOptions ? l.ngModelOptions.timezone : null); n = t.$options.createChild(l.ngModelOptions).createChild(e.datepickerOptions.ngModelOptions).createChild(t.$options).createChild({ timezone: a }) } return n } var h = this, m = { $setViewValue: angular.noop }, g = {}, b = []; t.addClass("uib-datepicker"), n.$set("role", "application"), e.datepickerOptions || (e.datepickerOptions = {}), this.modes = ["day", "month", "year"], ["customClass", "dateDisabled", "datepickerMode", "formatDay", "formatDayHeader", "formatDayTitle", "formatMonth", "formatMonthTitle", "formatYear", "maxDate", "maxMode", "minDate", "minMode", "monthColumns", "showWeeks", "shortcutPropagation", "startingDay", "yearColumns", "yearRows"].forEach(function (t) { switch (t) { case "customClass": case "dateDisabled": e[t] = e.datepickerOptions[t] || angular.noop; break; case "datepickerMode": e.datepickerMode = angular.isDefined(e.datepickerOptions.datepickerMode) ? e.datepickerOptions.datepickerMode : l.datepickerMode; break; case "formatDay": case "formatDayHeader": case "formatDayTitle": case "formatMonth": case "formatMonthTitle": case "formatYear": h[t] = angular.isDefined(e.datepickerOptions[t]) ? i(e.datepickerOptions[t])(e.$parent) : l[t]; break; case "monthColumns": case "showWeeks": case "shortcutPropagation": case "yearColumns": case "yearRows": h[t] = angular.isDefined(e.datepickerOptions[t]) ? e.datepickerOptions[t] : l[t]; break; case "startingDay": h.startingDay = angular.isDefined(e.datepickerOptions.startingDay) ? e.datepickerOptions.startingDay : angular.isNumber(l.startingDay) ? l.startingDay : (o.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7; break; case "maxDate": case "minDate": e.$watch("datepickerOptions." + t, function (e) { e ? angular.isDate(e) ? h[t] = d.fromTimezone(new Date(e), g.getOption("timezone")) : (u && r.warn("Literal date support has been deprecated, please switch to date object usage"), h[t] = new Date(s(e, "medium"))) : h[t] = l[t] ? d.fromTimezone(new Date(l[t]), g.getOption("timezone")) : null, h.refreshView() }); break; case "maxMode": case "minMode": e.datepickerOptions[t] ? e.$watch(function () { return e.datepickerOptions[t] }, function (n) { h[t] = e[t] = angular.isDefined(n) ? n : e.datepickerOptions[t], ("minMode" === t && h.modes.indexOf(e.datepickerOptions.datepickerMode) < h.modes.indexOf(h[t]) || "maxMode" === t && h.modes.indexOf(e.datepickerOptions.datepickerMode) > h.modes.indexOf(h[t])) && (e.datepickerMode = h[t], e.datepickerOptions.datepickerMode = h[t]) }) : h[t] = e[t] = l[t] || null } }), e.uniqueId = "datepicker-" + e.$id + "-" + Math.floor(1e4 * Math.random()), e.disabled = angular.isDefined(n.disabled) || !1, angular.isDefined(n.ngDisabled) && b.push(e.$parent.$watch(n.ngDisabled, function (t) { e.disabled = t, h.refreshView() })), e.isActive = function (t) { return 0 === h.compare(t.date, h.activeDate) ? (e.activeDateId = t.uid, !0) : !1 }, this.init = function (t) { m = t, g = f(m), e.datepickerOptions.initDate ? (h.activeDate = d.fromTimezone(e.datepickerOptions.initDate, g.getOption("timezone")) || new Date, e.$watch("datepickerOptions.initDate", function (e) { e && (m.$isEmpty(m.$modelValue) || m.$invalid) && (h.activeDate = d.fromTimezone(e, g.getOption("timezone")), h.refreshView()) })) : h.activeDate = new Date; var n = m.$modelValue ? new Date(m.$modelValue) : new Date; this.activeDate = isNaN(n) ? d.fromTimezone(new Date, g.getOption("timezone")) : d.fromTimezone(n, g.getOption("timezone")), m.$render = function () { h.render() } }, this.render = function () { if (m.$viewValue) { var e = new Date(m.$viewValue), t = !isNaN(e); t ? this.activeDate = d.fromTimezone(e, g.getOption("timezone")) : c || r.error('Datepicker directive: "ng-model" value must be a Date object') } this.refreshView() }, this.refreshView = function () { if (this.element) { e.selectedDt = null, this._refreshView(), e.activeDt && (e.activeDateId = e.activeDt.uid); var t = m.$viewValue ? new Date(m.$viewValue) : null; t = d.fromTimezone(t, g.getOption("timezone")), m.$setValidity("dateDisabled", !t || this.element && !this.isDisabled(t)) } }, this.createDateObject = function (t, n) { var a = m.$viewValue ? new Date(m.$viewValue) : null; a = d.fromTimezone(a, g.getOption("timezone")); var i = new Date; i = d.fromTimezone(i, g.getOption("timezone")); var o = this.compare(t, i), r = { date: t, label: d.filter(t, n), selected: a && 0 === this.compare(t, a), disabled: this.isDisabled(t), past: 0 > o, current: 0 === o, future: o > 0, customClass: this.customClass(t) || null }; return a && 0 === this.compare(t, a) && (e.selectedDt = r), h.activeDate && 0 === this.compare(r.date, h.activeDate) && (e.activeDt = r), r }, this.isDisabled = function (t) { return e.disabled || this.minDate && this.compare(t, this.minDate) < 0 || this.maxDate && this.compare(t, this.maxDate) > 0 || e.dateDisabled && e.dateDisabled({ date: t, mode: e.datepickerMode }) }, this.customClass = function (t) { return e.customClass({ date: t, mode: e.datepickerMode }) }, this.split = function (e, t) { for (var n = []; e.length > 0;) n.push(e.splice(0, t)); return n }, e.select = function (t) { if (e.datepickerMode === h.minMode) { var n = m.$viewValue ? d.fromTimezone(new Date(m.$viewValue), g.getOption("timezone")) : new Date(0, 0, 0, 0, 0, 0, 0); n.setFullYear(t.getFullYear(), t.getMonth(), t.getDate()), n = d.toTimezone(n, g.getOption("timezone")), m.$setViewValue(n), m.$render() } else h.activeDate = t, p(h.modes[h.modes.indexOf(e.datepickerMode) - 1]), e.$emit("uib:datepicker.mode"); e.$broadcast("uib:datepicker.focus") }, e.move = function (e) { var t = h.activeDate.getFullYear() + e * (h.step.years || 0), n = h.activeDate.getMonth() + e * (h.step.months || 0); h.activeDate.setFullYear(t, n, 1), h.refreshView() }, e.toggleMode = function (t) { t = t || 1, e.datepickerMode === h.maxMode && 1 === t || e.datepickerMode === h.minMode && -1 === t || (p(h.modes[h.modes.indexOf(e.datepickerMode) + t]), e.$emit("uib:datepicker.mode")) }, e.keys = { 13: "enter", 32: "space", 33: "pageup", 34: "pagedown", 35: "end", 36: "home", 37: "left", 38: "up", 39: "right", 40: "down" }; var v = function () { h.element[0].focus() }; e.$on("uib:datepicker.focus", v), e.keydown = function (t) { var n = e.keys[t.which]; if (n && !t.shiftKey && !t.altKey && !e.disabled) if (t.preventDefault(), h.shortcutPropagation || t.stopPropagation(), "enter" === n || "space" === n) { if (h.isDisabled(h.activeDate)) return; e.select(h.activeDate) } else !t.ctrlKey || "up" !== n && "down" !== n ? (h.handleKeyDown(n, t), h.refreshView()) : e.toggleMode("up" === n ? 1 : -1) }, t.on("keydown", function (t) { e.$apply(function () { e.keydown(t) }) }), e.$on("$destroy", function () { for (; b.length;) b.shift()() }) }]).controller("UibDaypickerController", ["$scope", "$element", "dateFilter", function (e, t, n) { function a(e, t) { return 1 !== t || e % 4 !== 0 || e % 100 === 0 && e % 400 !== 0 ? o[t] : 29 } function i(e) { var t = new Date(e); t.setDate(t.getDate() + 4 - (t.getDay() || 7)); var n = t.getTime(); return t.setMonth(0), t.setDate(1), Math.floor(Math.round((n - t) / 864e5) / 7) + 1 } var o = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; this.step = { months: 1 }, this.element = t, this.init = function (t) { angular.extend(t, this), e.showWeeks = t.showWeeks, t.refreshView() }, this.getDates = function (e, t) { for (var n, a = new Array(t), i = new Date(e), o = 0; t > o;) n = new Date(i), a[o++] = n, i.setDate(i.getDate() + 1); return a }, this._refreshView = function () { var t = this.activeDate.getFullYear(), a = this.activeDate.getMonth(), o = new Date(this.activeDate); o.setFullYear(t, a, 1); var r = this.startingDay - o.getDay(), s = r > 0 ? 7 - r : -r, l = new Date(o); s > 0 && l.setDate(-s + 1); for (var u = this.getDates(l, 42), c = 0; 42 > c; c++) u[c] = angular.extend(this.createDateObject(u[c], this.formatDay), { secondary: u[c].getMonth() !== a, uid: e.uniqueId + "-" + c }); e.labels = new Array(7); for (var d = 0; 7 > d; d++) e.labels[d] = { abbr: n(u[d].date, this.formatDayHeader), full: n(u[d].date, "EEEE") }; if (e.title = n(this.activeDate, this.formatDayTitle), e.rows = this.split(u, 7), e.showWeeks) { e.weekNumbers = []; for (var p = (11 - this.startingDay) % 7, f = e.rows.length, h = 0; f > h; h++) e.weekNumbers.push(i(e.rows[h][p].date)) } }, this.compare = function (e, t) { var n = new Date(e.getFullYear(), e.getMonth(), e.getDate()), a = new Date(t.getFullYear(), t.getMonth(), t.getDate()); return n.setFullYear(e.getFullYear()), a.setFullYear(t.getFullYear()), n - a }, this.handleKeyDown = function (e) { var t = this.activeDate.getDate(); if ("left" === e) t -= 1; else if ("up" === e) t -= 7; else if ("right" === e) t += 1; else if ("down" === e) t += 7; else if ("pageup" === e || "pagedown" === e) { var n = this.activeDate.getMonth() + ("pageup" === e ? -1 : 1); this.activeDate.setMonth(n, 1), t = Math.min(a(this.activeDate.getFullYear(), this.activeDate.getMonth()), t) } else "home" === e ? t = 1 : "end" === e && (t = a(this.activeDate.getFullYear(), this.activeDate.getMonth())); this.activeDate.setDate(t) } }]).controller("UibMonthpickerController", ["$scope", "$element", "dateFilter", function (e, t, n) { this.step = { years: 1 }, this.element = t, this.init = function (e) { angular.extend(e, this), e.refreshView() }, this._refreshView = function () { for (var t, a = new Array(12), i = this.activeDate.getFullYear(), o = 0; 12 > o; o++) t = new Date(this.activeDate), t.setFullYear(i, o, 1), a[o] = angular.extend(this.createDateObject(t, this.formatMonth), { uid: e.uniqueId + "-" + o }); e.title = n(this.activeDate, this.formatMonthTitle), e.rows = this.split(a, this.monthColumns), e.yearHeaderColspan = this.monthColumns > 3 ? this.monthColumns - 2 : 1 }, this.compare = function (e, t) { var n = new Date(e.getFullYear(), e.getMonth()), a = new Date(t.getFullYear(), t.getMonth()); return n.setFullYear(e.getFullYear()), a.setFullYear(t.getFullYear()), n - a }, this.handleKeyDown = function (e) { var t = this.activeDate.getMonth(); if ("left" === e) t -= 1; else if ("up" === e) t -= this.monthColumns; else if ("right" === e) t += 1; else if ("down" === e) t += this.monthColumns; else if ("pageup" === e || "pagedown" === e) { var n = this.activeDate.getFullYear() + ("pageup" === e ? -1 : 1); this.activeDate.setFullYear(n) } else "home" === e ? t = 0 : "end" === e && (t = 11); this.activeDate.setMonth(t) } }]).controller("UibYearpickerController", ["$scope", "$element", "dateFilter", function (e, t) { function n(e) { return parseInt((e - 1) / i, 10) * i + 1 } var a, i; this.element = t, this.yearpickerInit = function () { a = this.yearColumns, i = this.yearRows * a, this.step = { years: i } }, this._refreshView = function () { for (var t, o = new Array(i), r = 0, s = n(this.activeDate.getFullYear()) ; i > r; r++) t = new Date(this.activeDate), t.setFullYear(s + r, 0, 1), o[r] = angular.extend(this.createDateObject(t, this.formatYear), { uid: e.uniqueId + "-" + r }); e.title = [o[0].label, o[i - 1].label].join(" - "), e.rows = this.split(o, a), e.columns = a }, this.compare = function (e, t) { return e.getFullYear() - t.getFullYear() }, this.handleKeyDown = function (e) { var t = this.activeDate.getFullYear(); "left" === e ? t -= 1 : "up" === e ? t -= a : "right" === e ? t += 1 : "down" === e ? t += a : "pageup" === e || "pagedown" === e ? t += ("pageup" === e ? -1 : 1) * i : "home" === e ? t = n(this.activeDate.getFullYear()) : "end" === e && (t = n(this.activeDate.getFullYear()) + i - 1), this.activeDate.setFullYear(t) } }]).directive("uibDatepicker", function () { return { templateUrl: function (e, t) { return t.templateUrl || "uib/template/datepicker/datepicker.html" }, scope: { datepickerOptions: "=?" }, require: ["uibDatepicker", "^ngModel"], restrict: "A", controller: "UibDatepickerController", controllerAs: "datepicker", link: function (e, t, n, a) { var i = a[0], o = a[1]; i.init(o) } } }).directive("uibDaypicker", function () { return { templateUrl: function (e, t) { return t.templateUrl || "uib/template/datepicker/day.html" }, require: ["^uibDatepicker", "uibDaypicker"], restrict: "A", controller: "UibDaypickerController", link: function (e, t, n, a) { var i = a[0], o = a[1]; o.init(i) } } }).directive("uibMonthpicker", function () { return { templateUrl: function (e, t) { return t.templateUrl || "uib/template/datepicker/month.html" }, require: ["^uibDatepicker", "uibMonthpicker"], restrict: "A", controller: "UibMonthpickerController", link: function (e, t, n, a) { var i = a[0], o = a[1]; o.init(i) } } }).directive("uibYearpicker", function () { return { templateUrl: function (e, t) { return t.templateUrl || "uib/template/datepicker/year.html" }, require: ["^uibDatepicker", "uibYearpicker"], restrict: "A", controller: "UibYearpickerController", link: function (e, t, n, a) { var i = a[0]; angular.extend(i, a[1]), i.yearpickerInit(), i.refreshView() } } }), angular.module("ui.bootstrap.dateparser", []).service("uibDateParser", ["$log", "$locale", "dateFilter", "orderByFilter", "filterFilter", function (e, t, n, a, i) { function o(e) { return i(v, { key: e }, !0)[0] } function r(e) { var t = [], n = e.split(""), i = e.indexOf("'"); if (i > -1) { var o = !1; e = e.split(""); for (var r = i; r < e.length; r++) o ? ("'" === e[r] && (r + 1 < e.length && "'" === e[r + 1] ? (e[r + 1] = "$", n[r + 1] = "") : (n[r] = "", o = !1)), e[r] = "$") : "'" === e[r] && (e[r] = "$", n[r] = "", o = !0); e = e.join("") } return angular.forEach(v, function (a) { var i = e.indexOf(a.key); if (i > -1) { e = e.split(""), n[i] = "(" + a.regex + ")", e[i] = "$"; for (var o = i + 1, r = i + a.key.length; r > o; o++) n[o] = "", e[o] = "$"; e = e.join(""), t.push({ index: i, key: a.key, apply: a.apply, matcher: a.regex }) } }), { regex: new RegExp("^" + n.join("") + "$"), map: a(t, "index") } } function s(e) { for (var t, n, a = [], i = 0; i < e.length;) if (angular.isNumber(n)) { if ("'" === e.charAt(i)) (i + 1 >= e.length || "'" !== e.charAt(i + 1)) && (a.push(l(e, n, i)), n = null); else if (i === e.length) for (; n < e.length;) t = u(e, n), a.push(t), n = t.endIdx; i++ } else "'" !== e.charAt(i) ? (t = u(e, i), a.push(t.parser), i = t.endIdx) : (n = i, i++); return a } function l(e, t, n) { return function () { return e.substr(t + 1, n - t - 1) } } function u(e, t) { for (var n = e.substr(t), a = 0; a < v.length; a++) if (new RegExp("^" + v[a].key).test(n)) { var i = v[a]; return { endIdx: t + i.key.length, parser: i.formatter } } return { endIdx: t + 1, parser: function () { return n.charAt(0) } } } function c(e, t, n) { return 1 > n ? !1 : 1 === t && n > 28 ? 29 === n && (e % 4 === 0 && e % 100 !== 0 || e % 400 === 0) : 3 === t || 5 === t || 8 === t || 10 === t ? 31 > n : !0 } function d(e) { return parseInt(e, 10) } function p(e, t) { return e && t ? g(e, t) : e } function f(e, t) { return e && t ? g(e, t, !0) : e } function h(e, t) { e = e.replace(/:/g, ""); var n = Date.parse("Jan 01, 1970 00:00:00 " + e) / 6e4; return isNaN(n) ? t : n } function m(e, t) { return e = new Date(e.getTime()), e.setMinutes(e.getMinutes() + t), e } function g(e, t, n) { n = n ? -1 : 1; var a = e.getTimezoneOffset(), i = h(t, a); return m(e, n * (i - a)) } var b, v, y = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g; this.init = function () { b = t.id, this.parsers = {}, this.formatters = {}, v = [{ key: "yyyy", regex: "\\d{4}", apply: function (e) { this.year = +e }, formatter: function (e) { var t = new Date; return t.setFullYear(Math.abs(e.getFullYear())), n(t, "yyyy") } }, { key: "yy", regex: "\\d{2}", apply: function (e) { e = +e, this.year = 69 > e ? e + 2e3 : e + 1900 }, formatter: function (e) { var t = new Date; return t.setFullYear(Math.abs(e.getFullYear())), n(t, "yy") } }, { key: "y", regex: "\\d{1,4}", apply: function (e) { this.year = +e }, formatter: function (e) { var t = new Date; return t.setFullYear(Math.abs(e.getFullYear())), n(t, "y") } }, { key: "M!", regex: "0?[1-9]|1[0-2]", apply: function (e) { this.month = e - 1 }, formatter: function (e) { var t = e.getMonth(); return /^[0-9]$/.test(t) ? n(e, "MM") : n(e, "M") } }, { key: "MMMM", regex: t.DATETIME_FORMATS.MONTH.join("|"), apply: function (e) { this.month = t.DATETIME_FORMATS.MONTH.indexOf(e) }, formatter: function (e) { return n(e, "MMMM") } }, { key: "MMM", regex: t.DATETIME_FORMATS.SHORTMONTH.join("|"), apply: function (e) { this.month = t.DATETIME_FORMATS.SHORTMONTH.indexOf(e) }, formatter: function (e) { return n(e, "MMM") } }, { key: "MM", regex: "0[1-9]|1[0-2]", apply: function (e) { this.month = e - 1 }, formatter: function (e) { return n(e, "MM") } }, { key: "M", regex: "[1-9]|1[0-2]", apply: function (e) { this.month = e - 1 }, formatter: function (e) { return n(e, "M") } }, { key: "d!", regex: "[0-2]?[0-9]{1}|3[0-1]{1}", apply: function (e) { this.date = +e }, formatter: function (e) { var t = e.getDate(); return /^[1-9]$/.test(t) ? n(e, "dd") : n(e, "d") } }, { key: "dd", regex: "[0-2][0-9]{1}|3[0-1]{1}", apply: function (e) { this.date = +e }, formatter: function (e) { return n(e, "dd") } }, { key: "d", regex: "[1-2]?[0-9]{1}|3[0-1]{1}", apply: function (e) { this.date = +e }, formatter: function (e) { return n(e, "d") } }, { key: "EEEE", regex: t.DATETIME_FORMATS.DAY.join("|"), formatter: function (e) { return n(e, "EEEE") } }, { key: "EEE", regex: t.DATETIME_FORMATS.SHORTDAY.join("|"), formatter: function (e) { return n(e, "EEE") } }, { key: "HH", regex: "(?:0|1)[0-9]|2[0-3]", apply: function (e) { this.hours = +e }, formatter: function (e) { return n(e, "HH") } }, { key: "hh", regex: "0[0-9]|1[0-2]", apply: function (e) { this.hours = +e }, formatter: function (e) { return n(e, "hh") } }, { key: "H", regex: "1?[0-9]|2[0-3]", apply: function (e) { this.hours = +e }, formatter: function (e) { return n(e, "H") } }, { key: "h", regex: "[0-9]|1[0-2]", apply: function (e) { this.hours = +e }, formatter: function (e) { return n(e, "h") } }, { key: "mm", regex: "[0-5][0-9]", apply: function (e) { this.minutes = +e }, formatter: function (e) { return n(e, "mm") } }, { key: "m", regex: "[0-9]|[1-5][0-9]", apply: function (e) { this.minutes = +e }, formatter: function (e) { return n(e, "m") } }, { key: "sss", regex: "[0-9][0-9][0-9]", apply: function (e) { this.milliseconds = +e }, formatter: function (e) { return n(e, "sss") } }, { key: "ss", regex: "[0-5][0-9]", apply: function (e) { this.seconds = +e }, formatter: function (e) { return n(e, "ss") } }, { key: "s", regex: "[0-9]|[1-5][0-9]", apply: function (e) { this.seconds = +e }, formatter: function (e) { return n(e, "s") } }, { key: "a", regex: t.DATETIME_FORMATS.AMPMS.join("|"), apply: function (e) { 12 === this.hours && (this.hours = 0), "PM" === e && (this.hours += 12) }, formatter: function (e) { return n(e, "a") } }, { key: "Z", regex: "[+-]\\d{4}", apply: function (e) { var t = e.match(/([+-])(\d{2})(\d{2})/), n = t[1], a = t[2], i = t[3]; this.hours += d(n + a), this.minutes += d(n + i) }, formatter: function (e) { return n(e, "Z") } }, { key: "ww", regex: "[0-4][0-9]|5[0-3]", formatter: function (e) { return n(e, "ww") } }, { key: "w", regex: "[0-9]|[1-4][0-9]|5[0-3]", formatter: function (e) { return n(e, "w") } }, { key: "GGGG", regex: t.DATETIME_FORMATS.ERANAMES.join("|").replace(/\s/g, "\\s"), formatter: function (e) { return n(e, "GGGG") } }, { key: "GGG", regex: t.DATETIME_FORMATS.ERAS.join("|"), formatter: function (e) { return n(e, "GGG") } }, { key: "GG", regex: t.DATETIME_FORMATS.ERAS.join("|"), formatter: function (e) { return n(e, "GG") } }, { key: "G", regex: t.DATETIME_FORMATS.ERAS.join("|"), formatter: function (e) { return n(e, "G") } }], angular.version.major >= 1 && angular.version.minor > 4 && v.push({ key: "LLLL", regex: t.DATETIME_FORMATS.STANDALONEMONTH.join("|"), apply: function (e) { this.month = t.DATETIME_FORMATS.STANDALONEMONTH.indexOf(e) }, formatter: function (e) { return n(e, "LLLL") } }) }, this.init(), this.getParser = function (e) { var t = o(e); return t && t.apply || null }, this.overrideParser = function (e, t) { var n = o(e); n && angular.isFunction(t) && (this.parsers = {}, n.apply = t) }.bind(this), this.filter = function (e, n) { if (!angular.isDate(e) || isNaN(e) || !n) return ""; n = t.DATETIME_FORMATS[n] || n, t.id !== b && this.init(), this.formatters[n] || (this.formatters[n] = s(n)); var a = this.formatters[n]; return a.reduce(function (t, n) { return t + n(e) }, "") }, this.parse = function (n, a, i) { if (!angular.isString(n) || !a) return n; a = t.DATETIME_FORMATS[a] || a, a = a.replace(y, "\\$&"), t.id !== b && this.init(), this.parsers[a] || (this.parsers[a] = r(a, "apply")); var o = this.parsers[a], s = o.regex, l = o.map, u = n.match(s), d = !1; if (u && u.length) { var p, f; angular.isDate(i) && !isNaN(i.getTime()) ? p = { year: i.getFullYear(), month: i.getMonth(), date: i.getDate(), hours: i.getHours(), minutes: i.getMinutes(), seconds: i.getSeconds(), milliseconds: i.getMilliseconds() } : (i && e.warn("dateparser:", "baseDate is not a valid date"), p = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 }); for (var h = 1, m = u.length; m > h; h++) { var g = l[h - 1]; "Z" === g.matcher && (d = !0), g.apply && g.apply.call(p, u[h]) } var v = d ? Date.prototype.setUTCFullYear : Date.prototype.setFullYear, w = d ? Date.prototype.setUTCHours : Date.prototype.setHours; return c(p.year, p.month, p.date) && (!angular.isDate(i) || isNaN(i.getTime()) || d ? (f = new Date(0), v.call(f, p.year, p.month, p.date), w.call(f, p.hours || 0, p.minutes || 0, p.seconds || 0, p.milliseconds || 0)) : (f = new Date(i), v.call(f, p.year, p.month, p.date), w.call(f, p.hours, p.minutes, p.seconds, p.milliseconds))), f } }, this.toTimezone = p, this.fromTimezone = f, this.timezoneToOffset = h, this.addDateMinutes = m, this.convertTimezoneToLocal = g }]), angular.module("ui.bootstrap.isClass", []).directive("uibIsClass", ["$animate", function (e) { var t = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/, n = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/; return { restrict: "A", compile: function (a, i) { function o(e, t) { l.push(e), u.push({ scope: e, element: t }), h.forEach(function (t) { r(t, e) }), e.$on("$destroy", s) } function r(t, a) { var i = t.match(n), o = a.$eval(i[1]), r = i[2], s = c[t]; if (!s) { var l = function (t) { var n = null; u.some(function (e) { var a = e.scope.$eval(p); return a === t ? (n = e, !0) : void 0 }), s.lastActivated !== n && (s.lastActivated && e.removeClass(s.lastActivated.element, o), n && e.addClass(n.element, o), s.lastActivated = n) }; c[t] = s = { lastActivated: null, scope: a, watchFn: l, compareWithExp: r, watcher: a.$watch(r, l) } } s.watchFn(a.$eval(r)) } function s(e) { var t = e.targetScope, n = l.indexOf(t); if (l.splice(n, 1), u.splice(n, 1), l.length) { var a = l[0]; angular.forEach(c, function (e) { e.scope === t && (e.watcher = a.$watch(e.compareWithExp, e.watchFn), e.scope = a) }) } else c = {} } var l = [], u = [], c = {}, d = i.uibIsClass.match(t), p = d[2], f = d[1], h = f.split(","); return o } } }]), angular.module("ui.bootstrap.datepickerPopup", ["ui.bootstrap.datepicker", "ui.bootstrap.position"]).value("$datepickerPopupLiteralWarning", !0).constant("uibDatepickerPopupConfig", { altInputFormats: [], appendToBody: !1, clearText: "Clear", closeOnDateSelection: !0, closeText: "Done", currentText: "Today", datepickerPopup: "yyyy-MM-dd", datepickerPopupTemplateUrl: "uib/template/datepickerPopup/popup.html", datepickerTemplateUrl: "uib/template/datepicker/datepicker.html", html5Types: { date: "yyyy-MM-dd", "datetime-local": "yyyy-MM-ddTHH:mm:ss.sss", month: "yyyy-MM" }, onOpenFocus: !0, showButtonBar: !0, placement: "auto bottom-left" }).controller("UibDatepickerPopupController", ["$scope", "$element", "$attrs", "$compile", "$log", "$parse", "$window", "$document", "$rootScope", "$uibPosition", "dateFilter", "uibDateParser", "uibDatepickerPopupConfig", "$timeout", "uibDatepickerConfig", "$datepickerPopupLiteralWarning", function (e, t, n, a, i, o, r, s, l, u, c, d, p, f, h, m) { function g(t) { var n = d.parse(t, D, e.date); if (isNaN(n)) for (var a = 0; a < P.length; a++) if (n = d.parse(t, P[a], e.date), !isNaN(n)) return n; return n } function b(e) { if (angular.isNumber(e) && (e = new Date(e)), !e) return null; if (angular.isDate(e) && !isNaN(e)) return e; if (angular.isString(e)) { var t = g(e); if (!isNaN(t)) return d.toTimezone(t, I.getOption("timezone")) } return I.getOption("allowInvalid") ? e : void 0 } function v(e, t) { var a = e || t; return n.ngRequired || a ? (angular.isNumber(a) && (a = new Date(a)), a ? angular.isDate(a) && !isNaN(a) ? !0 : angular.isString(a) ? !isNaN(g(a)) : !1 : !0) : !0 } function y(n) { if (e.isOpen || !e.disabled) { var a = N[0], i = t[0].contains(n.target), o = void 0 !== a.contains && a.contains(n.target); !e.isOpen || i || o || e.$apply(function () { e.isOpen = !1 }) } } function w(n) { 27 === n.which && e.isOpen ? (n.preventDefault(), n.stopPropagation(), e.$apply(function () { e.isOpen = !1 }), t[0].focus()) : 40 !== n.which || e.isOpen || (n.preventDefault(), n.stopPropagation(), e.$apply(function () { e.isOpen = !0 })) } function $() { if (e.isOpen) { var a = angular.element(N[0].querySelector(".uib-datepicker-popup")), i = n.popupPlacement ? n.popupPlacement : p.placement, o = u.positionElements(t, a, i, T); a.css({ top: o.top + "px", left: o.left + "px" }), a.hasClass("uib-position-measure") && a.removeClass("uib-position-measure") } } function k(e) { var t; return angular.version.minor < 6 ? (t = angular.isObject(e.$options) ? e.$options : { timezone: null }, t.getOption = function (e) { return t[e] }) : t = e.$options, t } var D, M, T, O, x, C, E, S, A, F, I, N, P, U = !1, R = []; this.init = function (i) { if (F = i, I = k(F), M = angular.isDefined(n.closeOnDateSelection) ? e.$parent.$eval(n.closeOnDateSelection) : p.closeOnDateSelection, T = angular.isDefined(n.datepickerAppendToBody) ? e.$parent.$eval(n.datepickerAppendToBody) : p.appendToBody, O = angular.isDefined(n.onOpenFocus) ? e.$parent.$eval(n.onOpenFocus) : p.onOpenFocus, x = angular.isDefined(n.datepickerPopupTemplateUrl) ? n.datepickerPopupTemplateUrl : p.datepickerPopupTemplateUrl, C = angular.isDefined(n.datepickerTemplateUrl) ? n.datepickerTemplateUrl : p.datepickerTemplateUrl, P = angular.isDefined(n.altInputFormats) ? e.$parent.$eval(n.altInputFormats) : p.altInputFormats, e.showButtonBar = angular.isDefined(n.showButtonBar) ? e.$parent.$eval(n.showButtonBar) : p.showButtonBar, p.html5Types[n.type] ? (D = p.html5Types[n.type], U = !0) : (D = n.uibDatepickerPopup || p.datepickerPopup, n.$observe("uibDatepickerPopup", function (e) { var t = e || p.datepickerPopup; if (t !== D && (D = t, F.$modelValue = null, !D)) throw new Error("uibDatepickerPopup must have a date format specified.") })), !D) throw new Error("uibDatepickerPopup must have a date format specified."); if (U && n.uibDatepickerPopup) throw new Error("HTML5 date input types do not support custom formats."); E = angular.element("<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>"), E.attr({ "ng-model": "date", "ng-change": "dateSelection(date)", "template-url": x }), S = angular.element(E.children()[0]), S.attr("template-url", C), e.datepickerOptions || (e.datepickerOptions = {}), U && "month" === n.type && (e.datepickerOptions.datepickerMode = "month", e.datepickerOptions.minMode = "month"), S.attr("datepicker-options", "datepickerOptions"), U ? F.$formatters.push(function (t) { return e.date = d.fromTimezone(t, I.getOption("timezone")), t }) : (F.$$parserName = "date", F.$validators.date = v, F.$parsers.unshift(b), F.$formatters.push(function (t) { return F.$isEmpty(t) ? (e.date = t, t) : (angular.isNumber(t) && (t = new Date(t)), e.date = d.fromTimezone(t, I.getOption("timezone")), d.filter(e.date, D)) })), F.$viewChangeListeners.push(function () { e.date = g(F.$viewValue) }), t.on("keydown", w), N = a(E)(e), E.remove(), T ? s.find("body").append(N) : t.after(N), e.$on("$destroy", function () { for (e.isOpen === !0 && (l.$$phase || e.$apply(function () { e.isOpen = !1 })), N.remove(), t.off("keydown", w), s.off("click", y), A && A.off("scroll", $), angular.element(r).off("resize", $) ; R.length;) R.shift()() }) }, e.getText = function (t) { return e[t + "Text"] || p[t + "Text"] }, e.isDisabled = function (t) { "today" === t && (t = d.fromTimezone(new Date, I.getOption("timezone"))); var n = {}; return angular.forEach(["minDate", "maxDate"], function (t) { e.datepickerOptions[t] ? angular.isDate(e.datepickerOptions[t]) ? n[t] = new Date(e.datepickerOptions[t]) : (m && i.warn("Literal date support has been deprecated, please switch to date object usage"), n[t] = new Date(c(e.datepickerOptions[t], "medium"))) : n[t] = null }), e.datepickerOptions && n.minDate && e.compare(t, n.minDate) < 0 || n.maxDate && e.compare(t, n.maxDate) > 0 }, e.compare = function (e, t) { return new Date(e.getFullYear(), e.getMonth(), e.getDate()) - new Date(t.getFullYear(), t.getMonth(), t.getDate()) }, e.dateSelection = function (n) { e.date = n; var a = e.date ? d.filter(e.date, D) : null; t.val(a), F.$setViewValue(a), M && (e.isOpen = !1, t[0].focus()) }, e.keydown = function (n) { 27 === n.which && (n.stopPropagation(), e.isOpen = !1, t[0].focus()) }, e.select = function (t, n) { if (n.stopPropagation(), "today" === t) { var a = new Date; angular.isDate(e.date) ? (t = new Date(e.date), t.setFullYear(a.getFullYear(), a.getMonth(), a.getDate())) : (t = d.fromTimezone(a, I.getOption("timezone")), t.setHours(0, 0, 0, 0)) } e.dateSelection(t) }, e.close = function (n) { n.stopPropagation(), e.isOpen = !1, t[0].focus() }, e.disabled = angular.isDefined(n.disabled) || !1, n.ngDisabled && R.push(e.$parent.$watch(o(n.ngDisabled), function (t) { e.disabled = t })), e.$watch("isOpen", function (a) { a ? e.disabled ? e.isOpen = !1 : f(function () { $(), O && e.$broadcast("uib:datepicker.focus"), s.on("click", y); var a = n.popupPlacement ? n.popupPlacement : p.placement; T || u.parsePlacement(a)[2] ? (A = A || angular.element(u.scrollParent(t)), A && A.on("scroll", $)) : A = null, angular.element(r).on("resize", $) }, 0, !1) : (s.off("click", y), A && A.off("scroll", $), angular.element(r).off("resize", $)) }), e.$on("uib:datepicker.mode", function () { f($, 0, !1) }) }]).directive("uibDatepickerPopup", function () { return { require: ["ngModel", "uibDatepickerPopup"], controller: "UibDatepickerPopupController", scope: { datepickerOptions: "=?", isOpen: "=?", currentText: "@", clearText: "@", closeText: "@" }, link: function (e, t, n, a) { var i = a[0], o = a[1]; o.init(i) } } }).directive("uibDatepickerPopupWrap", function () { return { restrict: "A", transclude: !0, templateUrl: function (e, t) { return t.templateUrl || "uib/template/datepickerPopup/popup.html" } } }), angular.module("ui.bootstrap.position", []).factory("$uibPosition", ["$document", "$window", function (e, t) {
     var n, a, i = { normal: /(auto|scroll)/, hidden: /(auto|scroll|hidden)/ }, o = { auto: /\s?auto?\s?/i, primary: /^(top|bottom|left|right)$/, secondary: /^(top|bottom|left|right|center)$/, vertical: /^(top|bottom)$/ }, r = /(HTML|BODY)/; return {
         getRawNode: function (e) { return e.nodeName ? e : e[0] || e }, parseStyle: function (e) { return e = parseFloat(e), isFinite(e) ? e : 0 }, offsetParent: function (n) { function a(e) { return "static" === (t.getComputedStyle(e).position || "static") } n = this.getRawNode(n); for (var i = n.offsetParent || e[0].documentElement; i && i !== e[0].documentElement && a(i) ;) i = i.offsetParent; return i || e[0].documentElement }, scrollbarWidth: function (i) { if (i) { if (angular.isUndefined(a)) { var o = e.find("body"); o.addClass("uib-position-body-scrollbar-measure"), a = t.innerWidth - o[0].clientWidth, a = isFinite(a) ? a : 0, o.removeClass("uib-position-body-scrollbar-measure") } return a } if (angular.isUndefined(n)) { var r = angular.element('<div class="uib-position-scrollbar-measure"></div>'); e.find("body").append(r), n = r[0].offsetWidth - r[0].clientWidth, n = isFinite(n) ? n : 0, r.remove() } return n }, scrollbarPadding: function (e) { e = this.getRawNode(e); var n = t.getComputedStyle(e), a = this.parseStyle(n.paddingRight), i = this.parseStyle(n.paddingBottom), o = this.scrollParent(e, !1, !0), s = this.scrollbarWidth(r.test(o.tagName)); return { scrollbarWidth: s, widthOverflow: o.scrollWidth > o.clientWidth, right: a + s, originalRight: a, heightOverflow: o.scrollHeight > o.clientHeight, bottom: i + s, originalBottom: i } }, isScrollable: function (e, n) { e = this.getRawNode(e); var a = n ? i.hidden : i.normal, o = t.getComputedStyle(e); return a.test(o.overflow + o.overflowY + o.overflowX) }, scrollParent: function (n, a, o) { n = this.getRawNode(n); var r = a ? i.hidden : i.normal, s = e[0].documentElement, l = t.getComputedStyle(n); if (o && r.test(l.overflow + l.overflowY + l.overflowX)) return n; var u = "absolute" === l.position, c = n.parentElement || s; if (c === s || "fixed" === l.position) return s; for (; c.parentElement && c !== s;) { var d = t.getComputedStyle(c); if (u && "static" !== d.position && (u = !1), !u && r.test(d.overflow + d.overflowY + d.overflowX)) break; c = c.parentElement } return c }, position: function (n, a) { n = this.getRawNode(n); var i = this.offset(n); if (a) { var o = t.getComputedStyle(n); i.top -= this.parseStyle(o.marginTop), i.left -= this.parseStyle(o.marginLeft) } var r = this.offsetParent(n), s = { top: 0, left: 0 }; return r !== e[0].documentElement && (s = this.offset(r), s.top += r.clientTop - r.scrollTop, s.left += r.clientLeft - r.scrollLeft), { width: Math.round(angular.isNumber(i.width) ? i.width : n.offsetWidth), height: Math.round(angular.isNumber(i.height) ? i.height : n.offsetHeight), top: Math.round(i.top - s.top), left: Math.round(i.left - s.left) } }, offset: function (n) { n = this.getRawNode(n); var a = n.getBoundingClientRect(); return { width: Math.round(angular.isNumber(a.width) ? a.width : n.offsetWidth), height: Math.round(angular.isNumber(a.height) ? a.height : n.offsetHeight), top: Math.round(a.top + (t.pageYOffset || e[0].documentElement.scrollTop)), left: Math.round(a.left + (t.pageXOffset || e[0].documentElement.scrollLeft)) } }, viewportOffset: function (n, a, i) {
             n = this.getRawNode(n), i = i !== !1 ? !0 : !1; var o = n.getBoundingClientRect(), r = { top: 0, left: 0, bottom: 0, right: 0 }, s = a ? e[0].documentElement : this.scrollParent(n), l = s.getBoundingClientRect(); if (r.top = l.top + s.clientTop, r.left = l.left + s.clientLeft, s === e[0].documentElement && (r.top += t.pageYOffset, r.left += t.pageXOffset), r.bottom = r.top + s.clientHeight, r.right = r.left + s.clientWidth, i) {
                 var u = t.getComputedStyle(s);
                 r.top += this.parseStyle(u.paddingTop), r.bottom -= this.parseStyle(u.paddingBottom), r.left += this.parseStyle(u.paddingLeft), r.right -= this.parseStyle(u.paddingRight)
             } return { top: Math.round(o.top - r.top), bottom: Math.round(r.bottom - o.bottom), left: Math.round(o.left - r.left), right: Math.round(r.right - o.right) }
         }, parsePlacement: function (e) { var t = o.auto.test(e); return t && (e = e.replace(o.auto, "")), e = e.split("-"), e[0] = e[0] || "top", o.primary.test(e[0]) || (e[0] = "top"), e[1] = e[1] || "center", o.secondary.test(e[1]) || (e[1] = "center"), e[2] = t ? !0 : !1, e }, positionElements: function (e, n, a, i) { e = this.getRawNode(e), n = this.getRawNode(n); var r = angular.isDefined(n.offsetWidth) ? n.offsetWidth : n.prop("offsetWidth"), s = angular.isDefined(n.offsetHeight) ? n.offsetHeight : n.prop("offsetHeight"); a = this.parsePlacement(a); var l = i ? this.offset(e) : this.position(e), u = { top: 0, left: 0, placement: "" }; if (a[2]) { var c = this.viewportOffset(e, i), d = t.getComputedStyle(n), p = { width: r + Math.round(Math.abs(this.parseStyle(d.marginLeft) + this.parseStyle(d.marginRight))), height: s + Math.round(Math.abs(this.parseStyle(d.marginTop) + this.parseStyle(d.marginBottom))) }; if (a[0] = "top" === a[0] && p.height > c.top && p.height <= c.bottom ? "bottom" : "bottom" === a[0] && p.height > c.bottom && p.height <= c.top ? "top" : "left" === a[0] && p.width > c.left && p.width <= c.right ? "right" : "right" === a[0] && p.width > c.right && p.width <= c.left ? "left" : a[0], a[1] = "top" === a[1] && p.height - l.height > c.bottom && p.height - l.height <= c.top ? "bottom" : "bottom" === a[1] && p.height - l.height > c.top && p.height - l.height <= c.bottom ? "top" : "left" === a[1] && p.width - l.width > c.right && p.width - l.width <= c.left ? "right" : "right" === a[1] && p.width - l.width > c.left && p.width - l.width <= c.right ? "left" : a[1], "center" === a[1]) if (o.vertical.test(a[0])) { var f = l.width / 2 - r / 2; c.left + f < 0 && p.width - l.width <= c.right ? a[1] = "left" : c.right + f < 0 && p.width - l.width <= c.left && (a[1] = "right") } else { var h = l.height / 2 - p.height / 2; c.top + h < 0 && p.height - l.height <= c.bottom ? a[1] = "top" : c.bottom + h < 0 && p.height - l.height <= c.top && (a[1] = "bottom") } } switch (a[0]) { case "top": u.top = l.top - s; break; case "bottom": u.top = l.top + l.height; break; case "left": u.left = l.left - r; break; case "right": u.left = l.left + l.width } switch (a[1]) { case "top": u.top = l.top; break; case "bottom": u.top = l.top + l.height - s; break; case "left": u.left = l.left; break; case "right": u.left = l.left + l.width - r; break; case "center": o.vertical.test(a[0]) ? u.left = l.left + l.width / 2 - r / 2 : u.top = l.top + l.height / 2 - s / 2 } return u.top = Math.round(u.top), u.left = Math.round(u.left), u.placement = "center" === a[1] ? a[0] : a[0] + "-" + a[1], u }, adjustTop: function (e, t, n, a) { return -1 !== e.indexOf("top") && n !== a ? { top: t.top - a + "px" } : void 0 }, positionArrow: function (e, n) { e = this.getRawNode(e); var a = e.querySelector(".tooltip-inner, .popover-inner"); if (a) { var i = angular.element(a).hasClass("tooltip-inner"), r = e.querySelector(i ? ".tooltip-arrow" : ".arrow"); if (r) { var s = { top: "", bottom: "", left: "", right: "" }; if (n = this.parsePlacement(n), "center" === n[1]) return void angular.element(r).css(s); var l = "border-" + n[0] + "-width", u = t.getComputedStyle(r)[l], c = "border-"; c += o.vertical.test(n[0]) ? n[0] + "-" + n[1] : n[1] + "-" + n[0], c += "-radius"; var d = t.getComputedStyle(i ? a : e)[c]; switch (n[0]) { case "top": s.bottom = i ? "0" : "-" + u; break; case "bottom": s.top = i ? "0" : "-" + u; break; case "left": s.right = i ? "0" : "-" + u; break; case "right": s.left = i ? "0" : "-" + u } s[n[1]] = d, angular.element(r).css(s) } } }
     }
 }]), angular.module("ui.bootstrap.dropdown", ["ui.bootstrap.multiMap", "ui.bootstrap.position"]).constant("uibDropdownConfig", { appendToOpenClass: "uib-dropdown-open", openClass: "open" }).service("uibDropdownService", ["$document", "$rootScope", "$$multiMap", function (e, t, n) { var a = null, i = n.createNew(); this.isOnlyOpen = function (e, t) { var n = i.get(t); if (n) { var a = n.reduce(function (t, n) { return n.scope === e ? n : t }, {}); if (a) return 1 === n.length } return !1 }, this.open = function (t, n, r) { if (a || e.on("click", o), a && a !== t && (a.isOpen = !1), a = t, r) { var s = i.get(r); if (s) { var l = s.map(function (e) { return e.scope }); -1 === l.indexOf(t) && i.put(r, { scope: t }) } else i.put(r, { scope: t }) } }, this.close = function (t, n, r) { if (a === t && (e.off("click", o), e.off("keydown", this.keybindFilter), a = null), r) { var s = i.get(r); if (s) { var l = s.reduce(function (e, n) { return n.scope === t ? n : e }, {}); l && i.remove(r, l) } } }; var o = function (e) { if (a && a.isOpen && !(e && "disabled" === a.getAutoClose() || e && 3 === e.which)) { var n = a.getToggleElement(); if (!(e && n && n[0].contains(e.target))) { var i = a.getDropdownElement(); e && "outsideClick" === a.getAutoClose() && i && i[0].contains(e.target) || (a.focusToggleElement(), a.isOpen = !1, t.$$phase || a.$apply()) } } }; this.keybindFilter = function (e) { if (a) { var t = a.getDropdownElement(), n = a.getToggleElement(), i = t && t[0].contains(e.target), r = n && n[0].contains(e.target); 27 === e.which ? (e.stopPropagation(), a.focusToggleElement(), o()) : a.isKeynavEnabled() && -1 !== [38, 40].indexOf(e.which) && a.isOpen && (i || r) && (e.preventDefault(), e.stopPropagation(), a.focusDropdownEntry(e.which)) } } }]).controller("UibDropdownController", ["$scope", "$element", "$attrs", "$parse", "uibDropdownConfig", "uibDropdownService", "$animate", "$uibPosition", "$document", "$compile", "$templateRequest", function (e, t, n, a, i, o, r, s, l, u, c) { function d() { t.append(h.dropdownMenu) } var p, f, h = this, m = e.$new(), g = i.appendToOpenClass, b = i.openClass, v = angular.noop, y = n.onToggle ? a(n.onToggle) : angular.noop, w = !1, $ = l.find("body"); t.addClass("dropdown"), this.init = function () { n.isOpen && (f = a(n.isOpen), v = f.assign, e.$watch(f, function (e) { m.isOpen = !!e })), w = angular.isDefined(n.keyboardNav) }, this.toggle = function (e) { return m.isOpen = arguments.length ? !!e : !m.isOpen, angular.isFunction(v) && v(m, m.isOpen), m.isOpen }, this.isOpen = function () { return m.isOpen }, m.getToggleElement = function () { return h.toggleElement }, m.getAutoClose = function () { return n.autoClose || "always" }, m.getElement = function () { return t }, m.isKeynavEnabled = function () { return w }, m.focusDropdownEntry = function (e) { var n = h.dropdownMenu ? angular.element(h.dropdownMenu).find("a") : t.find("ul").eq(0).find("a"); switch (e) { case 40: h.selectedOption = angular.isNumber(h.selectedOption) ? h.selectedOption === n.length - 1 ? h.selectedOption : h.selectedOption + 1 : 0; break; case 38: h.selectedOption = angular.isNumber(h.selectedOption) ? 0 === h.selectedOption ? 0 : h.selectedOption - 1 : n.length - 1 } n[h.selectedOption].focus() }, m.getDropdownElement = function () { return h.dropdownMenu }, m.focusToggleElement = function () { h.toggleElement && h.toggleElement[0].focus() }, m.$watch("isOpen", function (i, f) { var w = null, k = !1; if (angular.isDefined(n.dropdownAppendTo)) { var D = a(n.dropdownAppendTo)(m); D && (w = angular.element(D)) } if (angular.isDefined(n.dropdownAppendToBody)) { var M = a(n.dropdownAppendToBody)(m); M !== !1 && (k = !0) } if (k && !w && (w = $), w && h.dropdownMenu && (i ? (w.append(h.dropdownMenu), t.on("$destroy", d)) : (t.off("$destroy", d), d())), w && h.dropdownMenu) { var T, O, x, C = s.positionElements(t, h.dropdownMenu, "bottom-left", !0), E = 0; if (T = { top: C.top + "px", display: i ? "block" : "none" }, O = h.dropdownMenu.hasClass("dropdown-menu-right"), O ? (T.left = "auto", x = s.scrollbarPadding(w), x.heightOverflow && x.scrollbarWidth && (E = x.scrollbarWidth), T.right = window.innerWidth - E - (C.left + t.prop("offsetWidth")) + "px") : (T.left = C.left + "px", T.right = "auto"), !k) { var S = s.offset(w); T.top = C.top - S.top + "px", O ? T.right = window.innerWidth - (C.left - S.left + t.prop("offsetWidth")) + "px" : T.left = C.left - S.left + "px" } h.dropdownMenu.css(T) } var A = w ? w : t, F = w ? g : b, I = A.hasClass(F), N = o.isOnlyOpen(e, w); if (I === !i) { var P; P = w ? N ? "removeClass" : "addClass" : i ? "addClass" : "removeClass", r[P](A, F).then(function () { angular.isDefined(i) && i !== f && y(e, { open: !!i }) }) } if (i) h.dropdownMenuTemplateUrl ? c(h.dropdownMenuTemplateUrl).then(function (e) { p = m.$new(), u(e.trim())(p, function (e) { var t = e; h.dropdownMenu.replaceWith(t), h.dropdownMenu = t, l.on("keydown", o.keybindFilter) }) }) : l.on("keydown", o.keybindFilter), m.focusToggleElement(), o.open(m, t, w); else { if (o.close(m, t, w), h.dropdownMenuTemplateUrl) { p && p.$destroy(); var U = angular.element('<ul class="dropdown-menu"></ul>'); h.dropdownMenu.replaceWith(U), h.dropdownMenu = U } h.selectedOption = null } angular.isFunction(v) && v(e, i) }) }]).directive("uibDropdown", function () { return { controller: "UibDropdownController", link: function (e, t, n, a) { a.init() } } }).directive("uibDropdownMenu", function () { return { restrict: "A", require: "?^uibDropdown", link: function (e, t, n, a) { if (a && !angular.isDefined(n.dropdownNested)) { t.addClass("dropdown-menu"); var i = n.templateUrl; i && (a.dropdownMenuTemplateUrl = i), a.dropdownMenu || (a.dropdownMenu = t) } } } }).directive("uibDropdownToggle", function () { return { require: "?^uibDropdown", link: function (e, t, n, a) { if (a) { t.addClass("dropdown-toggle"), a.toggleElement = t; var i = function (i) { i.preventDefault(), t.hasClass("disabled") || n.disabled || e.$apply(function () { a.toggle() }) }; t.on("click", i), t.attr({ "aria-haspopup": !0, "aria-expanded": !1 }), e.$watch(a.isOpen, function (e) { t.attr("aria-expanded", !!e) }), e.$on("$destroy", function () { t.off("click", i) }) } } } }), angular.module("ui.bootstrap.multiMap", []).factory("$$multiMap", function () { return { createNew: function () { var e = {}; return { entries: function () { return Object.keys(e).map(function (t) { return { key: t, value: e[t] } }) }, get: function (t) { return e[t] }, hasKey: function (t) { return !!e[t] }, keys: function () { return Object.keys(e) }, put: function (t, n) { e[t] || (e[t] = []), e[t].push(n) }, remove: function (t, n) { var a = e[t]; if (a) { var i = a.indexOf(n); -1 !== i && a.splice(i, 1), a.length || delete e[t] } } } } } }), angular.module("ui.bootstrap.modal", ["ui.bootstrap.multiMap", "ui.bootstrap.stackedMap", "ui.bootstrap.position"]).provider("$uibResolve", function () { var e = this; this.resolver = null, this.setResolver = function (e) { this.resolver = e }, this.$get = ["$injector", "$q", function (t, n) { var a = e.resolver ? t.get(e.resolver) : null; return { resolve: function (e, i, o, r) { if (a) return a.resolve(e, i, o, r); var s = []; return angular.forEach(e, function (e) { s.push(angular.isFunction(e) || angular.isArray(e) ? n.resolve(t.invoke(e)) : angular.isString(e) ? n.resolve(t.get(e)) : n.resolve(e)) }), n.all(s).then(function (t) { var n = {}, a = 0; return angular.forEach(e, function (e, i) { n[i] = t[a++] }), n }) } } }] }).directive("uibModalBackdrop", ["$animate", "$injector", "$uibModalStack", function (e, t, n) { function a(t, a, i) { i.modalInClass && (e.addClass(a, i.modalInClass), t.$on(n.NOW_CLOSING_EVENT, function (n, o) { var r = o(); t.modalOptions.animation ? e.removeClass(a, i.modalInClass).then(r) : r() })) } return { restrict: "A", compile: function (e, t) { return e.addClass(t.backdropClass), a } } }]).directive("uibModalWindow", ["$uibModalStack", "$q", "$animateCss", "$document", function (e, t, n, a) { return { scope: { index: "@" }, restrict: "A", transclude: !0, templateUrl: function (e, t) { return t.templateUrl || "uib/template/modal/window.html" }, link: function (i, o, r) { o.addClass(r.windowTopClass || ""), i.size = r.size, i.close = function (t) { var n = e.getTop(); n && n.value.backdrop && "static" !== n.value.backdrop && t.target === t.currentTarget && (t.preventDefault(), t.stopPropagation(), e.dismiss(n.key, "backdrop click")) }, o.on("click", i.close), i.$isRendered = !0; var s = t.defer(); i.$$postDigest(function () { s.resolve() }), s.promise.then(function () { var s = null; r.modalInClass && (s = n(o, { addClass: r.modalInClass }).start(), i.$on(e.NOW_CLOSING_EVENT, function (e, t) { var a = t(); n(o, { removeClass: r.modalInClass }).start().then(a) })), t.when(s).then(function () { var t = e.getTop(); if (t && e.modalRendered(t.key), !a[0].activeElement || !o[0].contains(a[0].activeElement)) { var n = o[0].querySelector("[autofocus]"); n ? n.focus() : o[0].focus() } }) }) } } }]).directive("uibModalAnimationClass", function () { return { compile: function (e, t) { t.modalAnimation && e.addClass(t.uibModalAnimationClass) } } }).directive("uibModalTransclude", ["$animate", function (e) { return { link: function (t, n, a, i, o) { o(t.$parent, function (t) { n.empty(), e.enter(t, n) }) } } }]).factory("$uibModalStack", ["$animate", "$animateCss", "$document", "$compile", "$rootScope", "$q", "$$multiMap", "$$stackedMap", "$uibPosition", function (e, t, n, a, i, o, r, s, l) { function u(e) { var t = "-"; return e.replace(S, function (e, n) { return (n ? t : "") + e.toLowerCase() }) } function c(e) { return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length) } function d() { for (var e = -1, t = D.keys(), n = 0; n < t.length; n++) D.get(t[n]).value.backdrop && (e = n); return e > -1 && O > e && (e = O), e } function p(e, t) { var n = D.get(e).value, a = n.appendTo; D.remove(e), x = D.top(), x && (O = parseInt(x.value.modalDomEl.attr("index"), 10)), m(n.modalDomEl, n.modalScope, function () { var t = n.openedClass || k; M.remove(t, e); var i = M.hasKey(t); a.toggleClass(t, i), !i && $ && $.heightOverflow && $.scrollbarWidth && (a.css($.originalRight ? { paddingRight: $.originalRight + "px" } : { paddingRight: "" }), $ = null), f(!0) }, n.closedDeferred), h(), t && t.focus ? t.focus() : a.focus && a.focus() } function f(e) { var t; D.length() > 0 && (t = D.top().value, t.modalDomEl.toggleClass(t.windowTopClass || "", e)) } function h() { if (y && -1 === d()) { var e = w; m(y, w, function () { e = null }), y = void 0, w = void 0 } } function m(t, n, a, i) { function r() { r.done || (r.done = !0, e.leave(t).then(function () { a && a(), t.remove(), i && i.resolve() }), n.$destroy()) } var s, l = null, u = function () { return s || (s = o.defer(), l = s.promise), function () { s.resolve() } }; return n.$broadcast(T.NOW_CLOSING_EVENT, u), o.when(l).then(r) } function g(e) { if (e.isDefaultPrevented()) return e; var t = D.top(); if (t) switch (e.which) { case 27: t.value.keyboard && (e.preventDefault(), i.$apply(function () { T.dismiss(t.key, "escape key press") })); break; case 9: var n = T.loadFocusElementList(t), a = !1; e.shiftKey ? (T.isFocusInFirstItem(e, n) || T.isModalFocused(e, t)) && (a = T.focusLastFocusableElement(n)) : T.isFocusInLastItem(e, n) && (a = T.focusFirstFocusableElement(n)), a && (e.preventDefault(), e.stopPropagation()) } } function b(e, t, n) { return !e.value.modalScope.$broadcast("modal.closing", t, n).defaultPrevented } function v() { Array.prototype.forEach.call(document.querySelectorAll("[" + C + "]"), function (e) { var t = parseInt(e.getAttribute(C), 10), n = t - 1; e.setAttribute(C, n), n || (e.removeAttribute(C), e.removeAttribute("aria-hidden")) }) } var y, w, $, k = "modal-open", D = s.createNew(), M = r.createNew(), T = { NOW_CLOSING_EVENT: "modal.stack.now-closing" }, O = 0, x = null, C = "data-bootstrap-modal-aria-hidden-count", E = "a[href], area[href], input:not([disabled]):not([tabindex='-1']), button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']), textarea:not([disabled]):not([tabindex='-1']), iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]", S = /[A-Z]/g; return i.$watch(d, function (e) { w && (w.index = e) }), n.on("keydown", g), i.$on("$destroy", function () { n.off("keydown", g) }), T.open = function (t, o) { function r(e) { function t(e) { var t = e.parent() ? e.parent().children() : []; return Array.prototype.filter.call(t, function (t) { return t !== e[0] }) } if (e && "BODY" !== e[0].tagName) return t(e).forEach(function (e) { var t = "true" === e.getAttribute("aria-hidden"), n = parseInt(e.getAttribute(C), 10); n || (n = t ? 1 : 0), e.setAttribute(C, n + 1), e.setAttribute("aria-hidden", "true") }), r(e.parent()) } var s = n[0].activeElement, c = o.openedClass || k; f(!1), x = D.top(), D.add(t, { deferred: o.deferred, renderDeferred: o.renderDeferred, closedDeferred: o.closedDeferred, modalScope: o.scope, backdrop: o.backdrop, keyboard: o.keyboard, openedClass: o.openedClass, windowTopClass: o.windowTopClass, animation: o.animation, appendTo: o.appendTo }), M.put(c, t); var p = o.appendTo, h = d(); h >= 0 && !y && (w = i.$new(!0), w.modalOptions = o, w.index = h, y = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>'), y.attr({ "class": "modal-backdrop", "ng-style": "{'z-index': 1040 + (index && 1 || 0) + index*10}", "uib-modal-animation-class": "fade", "modal-in-class": "in" }), o.backdropClass && y.addClass(o.backdropClass), o.animation && y.attr("modal-animation", "true"), a(y)(w), e.enter(y, p), l.isScrollable(p) && ($ = l.scrollbarPadding(p), $.heightOverflow && $.scrollbarWidth && p.css({ paddingRight: $.right + "px" }))); var m; o.component ? (m = document.createElement(u(o.component.name)), m = angular.element(m), m.attr({ resolve: "$resolve", "modal-instance": "$uibModalInstance", close: "$close($value)", dismiss: "$dismiss($value)" })) : m = o.content, O = x ? parseInt(x.value.modalDomEl.attr("index"), 10) + 1 : 0; var g = angular.element('<div uib-modal-window="modal-window"></div>'); g.attr({ "class": "modal", "template-url": o.windowTemplateUrl, "window-top-class": o.windowTopClass, role: "dialog", "aria-labelledby": o.ariaLabelledBy, "aria-describedby": o.ariaDescribedBy, size: o.size, index: O, animate: "animate", "ng-style": "{'z-index': 1050 + $$topModalIndex*10, display: 'block'}", tabindex: -1, "uib-modal-animation-class": "fade", "modal-in-class": "in" }).append(m), o.windowClass && g.addClass(o.windowClass), o.animation && g.attr("modal-animation", "true"), p.addClass(c), o.scope && (o.scope.$$topModalIndex = O), e.enter(a(g)(o.scope), p), D.top().value.modalDomEl = g, D.top().value.modalOpener = s, r(g) }, T.close = function (e, t) { var n = D.get(e); return v(), n && b(n, t, !0) ? (n.value.modalScope.$$uibDestructionScheduled = !0, n.value.deferred.resolve(t), p(e, n.value.modalOpener), !0) : !n }, T.dismiss = function (e, t) { var n = D.get(e); return v(), n && b(n, t, !1) ? (n.value.modalScope.$$uibDestructionScheduled = !0, n.value.deferred.reject(t), p(e, n.value.modalOpener), !0) : !n }, T.dismissAll = function (e) { for (var t = this.getTop() ; t && this.dismiss(t.key, e) ;) t = this.getTop() }, T.getTop = function () { return D.top() }, T.modalRendered = function (e) { var t = D.get(e); t && t.value.renderDeferred.resolve() }, T.focusFirstFocusableElement = function (e) { return e.length > 0 ? (e[0].focus(), !0) : !1 }, T.focusLastFocusableElement = function (e) { return e.length > 0 ? (e[e.length - 1].focus(), !0) : !1 }, T.isModalFocused = function (e, t) { if (e && t) { var n = t.value.modalDomEl; if (n && n.length) return (e.target || e.srcElement) === n[0] } return !1 }, T.isFocusInFirstItem = function (e, t) { return t.length > 0 ? (e.target || e.srcElement) === t[0] : !1 }, T.isFocusInLastItem = function (e, t) { return t.length > 0 ? (e.target || e.srcElement) === t[t.length - 1] : !1 }, T.loadFocusElementList = function (e) { if (e) { var t = e.value.modalDomEl; if (t && t.length) { var n = t[0].querySelectorAll(E); return n ? Array.prototype.filter.call(n, function (e) { return c(e) }) : n } } }, T }]).provider("$uibModal", function () { var e = { options: { animation: !0, backdrop: !0, keyboard: !0 }, $get: ["$rootScope", "$q", "$document", "$templateRequest", "$controller", "$uibResolve", "$uibModalStack", function (t, n, a, i, o, r, s) { function l(e) { return e.template ? n.when(e.template) : i(angular.isFunction(e.templateUrl) ? e.templateUrl() : e.templateUrl) } var u = {}, c = null; return u.getPromiseChain = function () { return c }, u.open = function (i) { function u() { return g } var d = n.defer(), p = n.defer(), f = n.defer(), h = n.defer(), m = { result: d.promise, opened: p.promise, closed: f.promise, rendered: h.promise, close: function (e) { return s.close(m, e) }, dismiss: function (e) { return s.dismiss(m, e) } }; if (i = angular.extend({}, e.options, i), i.resolve = i.resolve || {}, i.appendTo = i.appendTo || a.find("body").eq(0), !i.appendTo.length) throw new Error("appendTo element not found. Make sure that the element passed is in DOM."); if (!i.component && !i.template && !i.templateUrl) throw new Error("One of component or template or templateUrl options is required."); var g; g = i.component ? n.when(r.resolve(i.resolve, {}, null, null)) : n.all([l(i), r.resolve(i.resolve, {}, null, null)]); var b; return b = c = n.all([c]).then(u, u).then(function (e) { function n(t, n, a, i) { t.$scope = r, t.$scope.$resolve = {}, a ? t.$scope.$uibModalInstance = m : t.$uibModalInstance = m; var o = n ? e[1] : e; angular.forEach(o, function (e, n) { i && (t[n] = e), t.$scope.$resolve[n] = e }) } var a = i.scope || t, r = a.$new(); r.$close = m.close, r.$dismiss = m.dismiss, r.$on("$destroy", function () { r.$$uibDestructionScheduled || r.$dismiss("$uibUnscheduledDestruction") }); var l, u, c = { scope: r, deferred: d, renderDeferred: h, closedDeferred: f, animation: i.animation, backdrop: i.backdrop, keyboard: i.keyboard, backdropClass: i.backdropClass, windowTopClass: i.windowTopClass, windowClass: i.windowClass, windowTemplateUrl: i.windowTemplateUrl, ariaLabelledBy: i.ariaLabelledBy, ariaDescribedBy: i.ariaDescribedBy, size: i.size, openedClass: i.openedClass, appendTo: i.appendTo }, g = {}, b = {}; i.component ? (n(g, !1, !0, !1), g.name = i.component, c.component = g) : i.controller && (n(b, !0, !1, !0), u = o(i.controller, b, !0, i.controllerAs), i.controllerAs && i.bindToController && (l = u.instance, l.$close = r.$close, l.$dismiss = r.$dismiss, angular.extend(l, { $resolve: b.$scope.$resolve }, a)), l = u(), angular.isFunction(l.$onInit) && l.$onInit()), i.component || (c.content = e[0]), s.open(m, c), p.resolve(!0) }, function (e) { p.reject(e), d.reject(e) })["finally"](function () { c === b && (c = null) }), m }, u }] }; return e }), angular.module("ui.bootstrap.stackedMap", []).factory("$$stackedMap", function () { return { createNew: function () { var e = []; return { add: function (t, n) { e.push({ key: t, value: n }) }, get: function (t) { for (var n = 0; n < e.length; n++) if (t === e[n].key) return e[n] }, keys: function () { for (var t = [], n = 0; n < e.length; n++) t.push(e[n].key); return t }, top: function () { return e[e.length - 1] }, remove: function (t) { for (var n = -1, a = 0; a < e.length; a++) if (t === e[a].key) { n = a; break } return e.splice(n, 1)[0] }, removeTop: function () { return e.pop() }, length: function () { return e.length } } } } }), angular.module("ui.bootstrap.typeahead", ["ui.bootstrap.debounce", "ui.bootstrap.position"]).factory("uibTypeaheadParser", ["$parse", function (e) { var t = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/; return { parse: function (n) { var a = n.match(t); if (!a) throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_" but got "' + n + '".'); return { itemName: a[3], source: e(a[4]), viewMapper: e(a[2] || a[1]), modelMapper: e(a[1]) } } } }]).controller("UibTypeaheadController", ["$scope", "$element", "$attrs", "$compile", "$parse", "$q", "$timeout", "$document", "$window", "$rootScope", "$$debounce", "$uibPosition", "uibTypeaheadParser", function (e, t, n, a, i, o, r, s, l, u, c, d, p) { function f() { W.moveInProgress || (W.moveInProgress = !0, W.$digest()), J() } function h() { W.position = A ? d.offset(t) : d.position(t), W.position.top += t.prop("offsetHeight") } function m(e) { var t; return angular.version.minor < 6 ? (t = e.$options || {}, t.getOption = function (e) { return t[e] }) : t = e.$options, t } var g, b, v = [9, 13, 27, 38, 40], y = 200, w = e.$eval(n.typeaheadMinLength); w || 0 === w || (w = 1), e.$watch(n.typeaheadMinLength, function (e) { w = e || 0 === e ? e : 1 }); var $ = e.$eval(n.typeaheadWaitMs) || 0, k = e.$eval(n.typeaheadEditable) !== !1; e.$watch(n.typeaheadEditable, function (e) { k = e !== !1 }); var D, M, T = i(n.typeaheadLoading).assign || angular.noop, O = n.typeaheadShouldSelect ? i(n.typeaheadShouldSelect) : function (e, t) { var n = t.$event; return 13 === n.which || 9 === n.which }, x = i(n.typeaheadOnSelect), C = angular.isDefined(n.typeaheadSelectOnBlur) ? e.$eval(n.typeaheadSelectOnBlur) : !1, E = i(n.typeaheadNoResults).assign || angular.noop, S = n.typeaheadInputFormatter ? i(n.typeaheadInputFormatter) : void 0, A = n.typeaheadAppendToBody ? e.$eval(n.typeaheadAppendToBody) : !1, F = n.typeaheadAppendTo ? e.$eval(n.typeaheadAppendTo) : null, I = e.$eval(n.typeaheadFocusFirst) !== !1, N = n.typeaheadSelectOnExact ? e.$eval(n.typeaheadSelectOnExact) : !1, P = i(n.typeaheadIsOpen).assign || angular.noop, U = e.$eval(n.typeaheadShowHint) || !1, R = i(n.ngModel), Y = i(n.ngModel + "($$$p)"), z = function (t, n) { return angular.isFunction(R(e)) && b.getOption("getterSetter") ? Y(t, { $$$p: n }) : R.assign(t, n) }, V = p.parse(n.uibTypeahead), W = e.$new(), L = e.$on("$destroy", function () { W.$destroy() }); W.$on("$destroy", L); var q = "typeahead-" + W.$id + "-" + Math.floor(1e4 * Math.random()); t.attr({ "aria-autocomplete": "list", "aria-expanded": !1, "aria-owns": q }); var H, j; U && (H = angular.element("<div></div>"), H.css("position", "relative"), t.after(H), j = t.clone(), j.attr("placeholder", ""), j.attr("tabindex", "-1"), j.val(""), j.css({ position: "absolute", top: "0px", left: "0px", "border-color": "transparent", "box-shadow": "none", opacity: 1, background: "none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)", color: "#999" }), t.css({ position: "relative", "vertical-align": "top", "background-color": "transparent" }), j.attr("id") && j.removeAttr("id"), H.append(j), j.after(t)); var B = angular.element("<div uib-typeahead-popup></div>"); B.attr({ id: q, matches: "matches", active: "activeIdx", select: "select(activeIdx, evt)", "move-in-progress": "moveInProgress", query: "query", position: "position", "assign-is-open": "assignIsOpen(isOpen)", debounce: "debounceUpdate" }), angular.isDefined(n.typeaheadTemplateUrl) && B.attr("template-url", n.typeaheadTemplateUrl), angular.isDefined(n.typeaheadPopupTemplateUrl) && B.attr("popup-template-url", n.typeaheadPopupTemplateUrl); var _ = function () { U && j.val("") }, G = function () { W.matches = [], W.activeIdx = -1, t.attr("aria-expanded", !1), _() }, K = function (e) { return q + "-option-" + e }; W.$watch("activeIdx", function (e) { 0 > e ? t.removeAttr("aria-activedescendant") : t.attr("aria-activedescendant", K(e)) }); var X = function (e, t) { return W.matches.length > t && e ? e.toUpperCase() === W.matches[t].label.toUpperCase() : !1 }, Z = function (n, a) { var i = { $viewValue: n }; T(e, !0), E(e, !1), o.when(V.source(e, i)).then(function (o) { var r = n === g.$viewValue; if (r && D) if (o && o.length > 0) { W.activeIdx = I ? 0 : -1, E(e, !1), W.matches.length = 0; for (var s = 0; s < o.length; s++) i[V.itemName] = o[s], W.matches.push({ id: K(s), label: V.viewMapper(W, i), model: o[s] }); if (W.query = n, h(), t.attr("aria-expanded", !0), N && 1 === W.matches.length && X(n, 0) && (angular.isNumber(W.debounceUpdate) || angular.isObject(W.debounceUpdate) ? c(function () { W.select(0, a) }, angular.isNumber(W.debounceUpdate) ? W.debounceUpdate : W.debounceUpdate["default"]) : W.select(0, a)), U) { var l = W.matches[0].label; j.val(angular.isString(n) && n.length > 0 && l.slice(0, n.length).toUpperCase() === n.toUpperCase() ? n + l.slice(n.length) : "") } } else G(), E(e, !0); r && T(e, !1) }, function () { G(), T(e, !1), E(e, !0) }) }; A && (angular.element(l).on("resize", f), s.find("body").on("scroll", f)); var J = c(function () { W.matches.length && h(), W.moveInProgress = !1 }, y); W.moveInProgress = !1, W.query = void 0; var Q, et = function (e) { Q = r(function () { Z(e) }, $) }, tt = function () { Q && r.cancel(Q) }; G(), W.assignIsOpen = function (t) { P(e, t) }, W.select = function (a, i) { var o, s, l = {}; M = !0, l[V.itemName] = s = W.matches[a].model, o = V.modelMapper(e, l), z(e, o), g.$setValidity("editable", !0), g.$setValidity("parse", !0), x(e, { $item: s, $model: o, $label: V.viewMapper(e, l), $event: i }), G(), W.$eval(n.typeaheadFocusOnSelect) !== !1 && r(function () { t[0].focus() }, 0, !1) }, t.on("keydown", function (t) { if (0 !== W.matches.length && -1 !== v.indexOf(t.which)) { var n = O(e, { $event: t }); if (-1 === W.activeIdx && n || 9 === t.which && t.shiftKey) return G(), void W.$digest(); t.preventDefault(); var a; switch (t.which) { case 27: t.stopPropagation(), G(), e.$digest(); break; case 38: W.activeIdx = (W.activeIdx > 0 ? W.activeIdx : W.matches.length) - 1, W.$digest(), a = B[0].querySelectorAll(".uib-typeahead-match")[W.activeIdx], a.parentNode.scrollTop = a.offsetTop; break; case 40: W.activeIdx = (W.activeIdx + 1) % W.matches.length, W.$digest(), a = B[0].querySelectorAll(".uib-typeahead-match")[W.activeIdx], a.parentNode.scrollTop = a.offsetTop; break; default: n && W.$apply(function () { angular.isNumber(W.debounceUpdate) || angular.isObject(W.debounceUpdate) ? c(function () { W.select(W.activeIdx, t) }, angular.isNumber(W.debounceUpdate) ? W.debounceUpdate : W.debounceUpdate["default"]) : W.select(W.activeIdx, t) }) } } }), t.on("focus", function (e) { D = !0, 0 !== w || g.$viewValue || r(function () { Z(g.$viewValue, e) }, 0) }), t.on("blur", function (e) { C && W.matches.length && -1 !== W.activeIdx && !M && (M = !0, W.$apply(function () { angular.isObject(W.debounceUpdate) && angular.isNumber(W.debounceUpdate.blur) ? c(function () { W.select(W.activeIdx, e) }, W.debounceUpdate.blur) : W.select(W.activeIdx, e) })), !k && g.$error.editable && (g.$setViewValue(), W.$apply(function () { g.$setValidity("editable", !0), g.$setValidity("parse", !0) }), t.val("")), D = !1, M = !1 }); var nt = function (n) { t[0] !== n.target && 3 !== n.which && 0 !== W.matches.length && (G(), u.$$phase || e.$digest()) }; s.on("click", nt), e.$on("$destroy", function () { s.off("click", nt), (A || F) && at.remove(), A && (angular.element(l).off("resize", f), s.find("body").off("scroll", f)), B.remove(), U && H.remove() }); var at = a(B)(W); A ? s.find("body").append(at) : F ? angular.element(F).eq(0).append(at) : t.after(at), this.init = function (t) { g = t, b = m(g), W.debounceUpdate = i(b.getOption("debounce"))(e), g.$parsers.unshift(function (t) { return D = !0, 0 === w || t && t.length >= w ? $ > 0 ? (tt(), et(t)) : Z(t) : (T(e, !1), tt(), G()), k ? t : t ? void g.$setValidity("editable", !1) : (g.$setValidity("editable", !0), null) }), g.$formatters.push(function (t) { var n, a, i = {}; return k || g.$setValidity("editable", !0), S ? (i.$model = t, S(e, i)) : (i[V.itemName] = t, n = V.viewMapper(e, i), i[V.itemName] = void 0, a = V.viewMapper(e, i), n !== a ? n : t) }) } }]).directive("uibTypeahead", function () { return { controller: "UibTypeaheadController", require: ["ngModel", "uibTypeahead"], link: function (e, t, n, a) { a[1].init(a[0]) } } }).directive("uibTypeaheadPopup", ["$$debounce", function (e) { return { scope: { matches: "=", query: "=", active: "=", position: "&", moveInProgress: "=", select: "&", assignIsOpen: "&", debounce: "&" }, replace: !0, templateUrl: function (e, t) { return t.popupTemplateUrl || "uib/template/typeahead/typeahead-popup.html" }, link: function (t, n, a) { t.templateUrl = a.templateUrl, t.isOpen = function () { var e = t.matches.length > 0; return t.assignIsOpen({ isOpen: e }), e }, t.isActive = function (e) { return t.active === e }, t.selectActive = function (e) { t.active = e }, t.selectMatch = function (n, a) { var i = t.debounce(); angular.isNumber(i) || angular.isObject(i) ? e(function () { t.select({ activeIdx: n, evt: a }) }, angular.isNumber(i) ? i : i["default"]) : t.select({ activeIdx: n, evt: a }) } } } }]).directive("uibTypeaheadMatch", ["$templateRequest", "$compile", "$parse", function (e, t, n) { return { scope: { index: "=", match: "=", query: "=" }, link: function (a, i, o) { var r = n(o.templateUrl)(a.$parent) || "uib/template/typeahead/typeahead-match.html"; e(r).then(function (e) { var n = angular.element(e.trim()); i.replaceWith(n), t(n)(a) }) } } }]).filter("uibTypeaheadHighlight", ["$sce", "$injector", "$log", function (e, t, n) { function a(e) { return e.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1") } function i(e) { return /<.*>/g.test(e) } var o; return o = t.has("$sanitize"), function (t, r) { return !o && i(t) && n.warn("Unsafe use of typeahead please use ngSanitize"), t = r ? ("" + t).replace(new RegExp(a(r), "gi"), "<strong>$&</strong>") : t, o || (t = e.trustAsHtml(t)), t } }]), angular.module("ui.bootstrap.debounce", []).factory("$$debounce", ["$timeout", function (e) { return function (t, n) { var a; return function () { var i = this, o = Array.prototype.slice.call(arguments); a && e.cancel(a), a = e(function () { t.apply(i, o) }, n) } } }]), angular.module("ui.bootstrap.tabs", []).controller("UibTabsetController", ["$scope", function (e) { function t(e) { for (var t = 0; t < a.tabs.length; t++) if (a.tabs[t].index === e) return t } var n, a = this; a.tabs = [], a.select = function (e, o) { if (!i) { var r = t(n), s = a.tabs[r]; if (s) { if (s.tab.onDeselect({ $event: o, $selectedIndex: e }), o && o.isDefaultPrevented()) return; s.tab.active = !1 } var l = a.tabs[e]; l ? (l.tab.onSelect({ $event: o }), l.tab.active = !0, a.active = l.index, n = l.index) : !l && angular.isDefined(n) && (a.active = null, n = null) } }, a.addTab = function (e) { if (a.tabs.push({ tab: e, index: e.index }), a.tabs.sort(function (e, t) { return e.index > t.index ? 1 : e.index < t.index ? -1 : 0 }), e.index === a.active || !angular.isDefined(a.active) && 1 === a.tabs.length) { var n = t(e.index); a.select(n) } }, a.removeTab = function (e) { for (var t, n = 0; n < a.tabs.length; n++) if (a.tabs[n].tab === e) { t = n; break } if (a.tabs[t].index === a.active) { var i = t === a.tabs.length - 1 ? t - 1 : t + 1 % a.tabs.length; a.select(i) } a.tabs.splice(t, 1) }, e.$watch("tabset.active", function (e) { angular.isDefined(e) && e !== n && a.select(t(e)) }); var i; e.$on("$destroy", function () { i = !0 }) }]).directive("uibTabset", function () { return { transclude: !0, replace: !0, scope: {}, bindToController: { active: "=?", type: "@" }, controller: "UibTabsetController", controllerAs: "tabset", templateUrl: function (e, t) { return t.templateUrl || "uib/template/tabs/tabset.html" }, link: function (e, t, n) { e.vertical = angular.isDefined(n.vertical) ? e.$parent.$eval(n.vertical) : !1, e.justified = angular.isDefined(n.justified) ? e.$parent.$eval(n.justified) : !1 } } }).directive("uibTab", ["$parse", function (e) { return { require: "^uibTabset", replace: !0, templateUrl: function (e, t) { return t.templateUrl || "uib/template/tabs/tab.html" }, transclude: !0, scope: { heading: "@", index: "=?", classes: "@?", onSelect: "&select", onDeselect: "&deselect" }, controller: function () { }, controllerAs: "tab", link: function (t, n, a, i, o) { t.disabled = !1, a.disable && t.$parent.$watch(e(a.disable), function (e) { t.disabled = !!e }), angular.isUndefined(a.index) && (t.index = i.tabs && i.tabs.length ? Math.max.apply(null, i.tabs.map(function (e) { return e.index })) + 1 : 0), angular.isUndefined(a.classes) && (t.classes = ""), t.select = function (e) { if (!t.disabled) { for (var n, a = 0; a < i.tabs.length; a++) if (i.tabs[a].tab === t) { n = a; break } i.select(n, e) } }, i.addTab(t), t.$on("$destroy", function () { i.removeTab(t) }), t.$transcludeFn = o } } }]).directive("uibTabHeadingTransclude", function () { return { restrict: "A", require: "^uibTab", link: function (e, t) { e.$watch("headingElement", function (e) { e && (t.html(""), t.append(e)) }) } } }).directive("uibTabContentTransclude", function () {
     function e(e) {
         return e.tagName && (e.hasAttribute("uib-tab-heading") || e.hasAttribute("data-uib-tab-heading") || e.hasAttribute("x-uib-tab-heading") || "uib-tab-heading" === e.tagName.toLowerCase() || "data-uib-tab-heading" === e.tagName.toLowerCase() || "x-uib-tab-heading" === e.tagName.toLowerCase() || "uib:tab-heading" === e.tagName.toLowerCase())
     } return { restrict: "A", require: "^uibTabset", link: function (t, n, a) { var i = t.$eval(a.uibTabContentTransclude).tab; i.$transcludeFn(i.$parent, function (t) { angular.forEach(t, function (t) { e(t) ? i.headingElement = t : n.append(t) }) }) } }
 }), angular.module("uib/template/datepicker/datepicker.html", []).run(["$templateCache", function (e) { e.put("uib/template/datepicker/datepicker.html", '<div ng-switch="datepickerMode">\n  <div uib-daypicker ng-switch-when="day" tabindex="0" class="uib-daypicker"></div>\n  <div uib-monthpicker ng-switch-when="month" tabindex="0" class="uib-monthpicker"></div>\n  <div uib-yearpicker ng-switch-when="year" tabindex="0" class="uib-yearpicker"></div>\n</div>\n') }]), angular.module("uib/template/datepicker/day.html", []).run(["$templateCache", function (e) { e.put("uib/template/datepicker/day.html", '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-left"></i><span class="sr-only">previous</span></button></th>\n      <th colspan="{{::5 + showWeeks}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-right"></i><span class="sr-only">next</span></button></th>\n    </tr>\n    <tr>\n      <th ng-if="showWeeks" class="text-center"></th>\n      <th ng-repeat="label in ::labels track by $index" class="text-center"><small aria-label="{{::label.full}}">{{::label.abbr}}</small></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-weeks" ng-repeat="row in rows track by $index" role="row">\n      <td ng-if="showWeeks" class="text-center h6"><em>{{ weekNumbers[$index] }}</em></td>\n      <td ng-repeat="dt in row" class="uib-day text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" class="btn btn-default btn-sm"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-muted\': dt.secondary, \'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n') }]), angular.module("uib/template/datepicker/month.html", []).run(["$templateCache", function (e) { e.put("uib/template/datepicker/month.html", '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-left"></i><span class="sr-only">previous</span></button></th>\n      <th colspan="{{::yearHeaderColspan}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-right"></i><span class="sr-only">next</span></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-months" ng-repeat="row in rows track by $index" role="row">\n      <td ng-repeat="dt in row" class="uib-month text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" class="btn btn-default"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n') }]), angular.module("uib/template/datepicker/year.html", []).run(["$templateCache", function (e) { e.put("uib/template/datepicker/year.html", '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-left"></i><span class="sr-only">previous</span></button></th>\n      <th colspan="{{::columns - 2}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i aria-hidden="true" class="glyphicon glyphicon-chevron-right"></i><span class="sr-only">next</span></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-years" ng-repeat="row in rows track by $index" role="row">\n      <td ng-repeat="dt in row" class="uib-year text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" class="btn btn-default"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n') }]), angular.module("uib/template/datepickerPopup/popup.html", []).run(["$templateCache", function (e) { e.put("uib/template/datepickerPopup/popup.html", '<ul role="presentation" class="uib-datepicker-popup dropdown-menu uib-position-measure" dropdown-nested ng-if="isOpen" ng-keydown="keydown($event)" ng-click="$event.stopPropagation()">\n  <li ng-transclude></li>\n  <li ng-if="showButtonBar" class="uib-button-bar">\n    <span class="btn-group pull-left">\n      <button type="button" class="btn btn-sm btn-info uib-datepicker-current" ng-click="select(\'today\', $event)" ng-disabled="isDisabled(\'today\')">{{ getText(\'current\') }}</button>\n      <button type="button" class="btn btn-sm btn-danger uib-clear" ng-click="select(null, $event)">{{ getText(\'clear\') }}</button>\n    </span>\n    <button type="button" class="btn btn-sm btn-success pull-right uib-close" ng-click="close($event)">{{ getText(\'close\') }}</button>\n  </li>\n</ul>\n') }]), angular.module("uib/template/modal/window.html", []).run(["$templateCache", function (e) { e.put("uib/template/modal/window.html", "<div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n") }]), angular.module("uib/template/typeahead/typeahead-match.html", []).run(["$templateCache", function (e) { e.put("uib/template/typeahead/typeahead-match.html", '<a href\n   tabindex="-1"\n   ng-bind-html="match.label | uibTypeaheadHighlight:query"\n   ng-attr-title="{{match.label}}"></a>\n') }]), angular.module("uib/template/typeahead/typeahead-popup.html", []).run(["$templateCache", function (e) { e.put("uib/template/typeahead/typeahead-popup.html", '<ul class="dropdown-menu" ng-show="isOpen() && !moveInProgress" ng-style="{top: position().top+\'px\', left: position().left+\'px\'}" role="listbox" aria-hidden="{{!isOpen()}}">\n    <li class="uib-typeahead-match" ng-repeat="match in matches track by $index" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index, $event)" role="option" id="{{::match.id}}">\n        <div uib-typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n    </li>\n</ul>\n') }]), angular.module("uib/template/tabs/tab.html", []).run(["$templateCache", function (e) { e.put("uib/template/tabs/tab.html", '<li ng-class="[{active: active, disabled: disabled}, classes]" class="uib-tab nav-item">\n  <a href ng-click="select($event)" class="nav-link" uib-tab-heading-transclude>{{heading}}</a>\n</li>\n') }]), angular.module("uib/template/tabs/tabset.html", []).run(["$templateCache", function (e) { e.put("uib/template/tabs/tabset.html", '<div>\n  <ul class="nav nav-{{tabset.type || \'tabs\'}}" ng-class="{\'nav-stacked\': vertical, \'nav-justified\': justified}" ng-transclude></ul>\n  <div class="tab-content">\n    <div class="tab-pane"\n         ng-repeat="tab in tabset.tabs"\n         ng-class="{active: tabset.active === tab.index}"\n         uib-tab-content-transclude="tab">\n    </div>\n  </div>\n</div>\n') }]), angular.module("ui.bootstrap.datepicker").run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find("head").prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>'), angular.$$uibDatepickerCss = !0 }), angular.module("ui.bootstrap.datepickerPopup").run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find("head").prepend('<style type="text/css">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>'), angular.$$uibDatepickerpopupCss = !0 }), angular.module("ui.bootstrap.position").run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find("head").prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'), angular.$$uibPositionCss = !0 }), angular.module("ui.bootstrap.typeahead").run(function () { !angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find("head").prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'), angular.$$uibTypeaheadCss = !0 });